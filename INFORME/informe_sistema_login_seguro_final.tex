\documentclass[12pt,a4paper]{article}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{setspace}
\usepackage{hyperref}
\usepackage{color}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{float}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{helvet}

% Usar Arial como fuente principal
\renewcommand{\familydefault}{\sfdefault}

% Ajuste de headheight
\setlength{\headheight}{15pt}

% Configuración de márgenes - A4
\geometry{
  paper=a4paper,
  top=2.5cm,
  bottom=2.5cm,
  left=2.5cm,
  right=2.5cm
}

% Configuración de espaciado reducido
\onehalfspacing

% Reducir espaciado entre items
\usepackage{enumitem}
\setlist[description]{itemsep=0pt, parsep=0pt, leftmargin=2cm}
\setlist[enumerate]{itemsep=2pt, parsep=2pt}
\setlist[itemize]{itemsep=2pt, parsep=2pt}

% Configuración de encabezado y pie
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\textit{Sistema de Login Seguro}}
\fancyhead[R]{\thepage}
\fancyfoot[C]{\textit{Criptografía y Ciberseguridad - TP Final}}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0.5pt}

% Configuración de código
\lstset{
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  stringstyle=\color{red},
  breaklines=true,
  numbers=left,
  numberstyle=\tiny,
  backgroundcolor=\color{lightgray!30},
  frame=single,
  captionpos=b
}

% Información del documento
\title{
  \vspace{2cm}
  \includegraphics[width=4cm]{image.png}\\[1cm]
  {\LARGE \textbf{SISTEMA DE AUTENTICACIÓN SEGURO}}\\
  {\large Diseño e Implementación de Mejores Prácticas en Criptografía}\\
  \vspace{0.5cm}
  {\normalsize Trabajo Práctico Final - Noviembre 2025}
}

\author{\textbf{Criptografía y Ciberseguridad}}
\date{}

\begin{document}

\maketitle

\vspace{0.5cm}

\section*{RESUMEN EJECUTIVO}

El presente informe detalla el diseño de un sistema de autenticación seguro. Se utilizan algoritmos de hashing modernos (Argon2id), tokens JWT con rotación automática, refresh token stateful, y múltiples controles preventivos. El sistema cumple con OWASP Top 10, NIST SP 800-63B y principios de privacidad por diseño.

\section{REQUISITOS FUNCIONALES Y NO FUNCIONALES}

\subsection{Requisitos Funcionales (RF)}

Los RF especifican qué funcionalidades debe proporcionar el sistema:

\begin{description}
  \item[RF1 - Registro] El sistema permite crear una cuenta con email y contraseña únicos.
  \item[RF2 - Verificación de Email] Tras el registro, el usuario verifica su email mediante enlace único y de corta duración.
  \item[RF3 - Login] El usuario autenticado con email y contraseña correctos recibe tokens de sesión.
  \item[RF4 - Logout] El usuario cierra su sesión de forma segura revocando todos los tokens.
  \item[RF5 - Cambio de Contraseña] El usuario autenticado cambia su contraseña (requiriendo la antigua).
  \item[RF6 - Recuperación de Contraseña] Usuario que olvidó su contraseña recibe enlace de reseteo por email.
  \item[RF7 - Gestión de Sesión (Refresh)] El sistema renueva sesiones expiradas sin pedir credenciales, mediante refresh token.
\end{description}

\subsection{Requisitos No Funcionales (RNF)}

Los RNF especifican cómo el sistema implementa seguridad y calidad:

\begin{description}
  \item[RNF1 - Confidencialidad] Las contraseñas se almacenan hasheadas (Argon2id), nunca en texto plano.
  \item[RNF2 - Resistencia a Fuerza Bruta] Rate limiting en endpoints críticos (login, recuperación).
  \item[RNF3 - Transporte Seguro] Comunicación cifrada con HTTPS/TLS 1.2+.
  \item[RNF4 - Gestión Segura de Sesión] Sesiones gestionadas por JWT (acceso) + cookies seguras (refresh).
  \item[RNF5 - Prevención XSS] Tokens de sesión en cookies HttpOnly, no accesibles por JavaScript.
  \item[RNF6 - Prevención CSRF] Cookies con flag SameSite=Strict.
  \item[RNF7 - Mínimo Privilegio] Tokens contienen solo user\_id y roles, sin información sensible (PII).
\end{description}

\section{MODELO DE DATOS}

El modelo prioriza seguridad utilizando UUIDs como claves primarias para mitigar enumeración de recursos.

\subsection{Tabla: Usuarios}

\begin{table}[H]
  \centering
  \small
  \begin{tabular}{|l|l|p{3cm}|}
    \hline
    \textbf{Columna} & \textbf{Tipo} & \textbf{Descripción} \\
    \hline
    id & UUID PK & Identificador único (UUID v4) \\
    \hline
    email & VARCHAR UNIQUE & Email como identificador de login \\
    \hline
    password\_hash & VARCHAR & Hash Argon2id de la contraseña \\
    \hline
    email\_verified & BOOLEAN & Flag de verificación de email \\
    \hline
    created\_at & TIMESTAMP & Fecha de creación \\
    \hline
    updated\_at & TIMESTAMP & Fecha de última modificación \\
    \hline
  \end{tabular}
\end{table}

\subsection{Tabla: Sesiones}

Tabla fundamental para gestión stateful de refresh tokens, permitiendo revocación y rotación.

\begin{table}[H]
  \centering
  \small
  \begin{tabular}{|l|l|p{2.5cm}|}
    \hline
    \textbf{Columna} & \textbf{Tipo} & \textbf{Descripción} \\
    \hline
    id & UUID PK & Identificador de sesión \\
    \hline
    user\_id & UUID FK & Usuario propietario \\
    \hline
    refresh\_token\_hash & VARCHAR UNIQUE & Hash SHA-256 del refresh token \\
    \hline
    ip\_address & VARCHAR & IP de origen (auditoría) \\
    \hline
    user\_agent & TEXT & Metadata del cliente \\
    \hline
    expires\_at & TIMESTAMP & Expiración del refresh token \\
    \hline
    created\_at & TIMESTAMP & Creación de sesión \\
    \hline
  \end{tabular}
\end{table}

\textbf{Nota Crítica:} El hash del refresh token se almacena, no el token en texto plano. Si la BD fuese comprometida, los atacantes no podrían usar los tokens directamente.

\section{FLUJOS DE AUTENTICACIÓN}

\subsection{Flujo de Login y Emisión de Tokens}

\begin{enumerate}
  \item \textbf{Petición}: Cliente envía email y password a \texttt{/api/login}.
  \item \textbf{Rate Limiting}: Servidor aplica límites para mitigar fuerza bruta.
  \item \textbf{Verificación}: Se busca el usuario por email y verifica contraseña con \texttt{argon2.verify()}. Error genérico 401 para evitar enumeración.
  \item \textbf{Generación de Tokens} (exitosa):
    \begin{itemize}
      \item \textbf{Access Token (JWT)}: Payload mínimo (sub: user.id), expiración 15 min, algoritmo RS256/ES256.
      \item \textbf{Refresh Token (Opaque)}: String aleatorio 32 bytes, expiración 7 días.
    \end{itemize}
  \item \textbf{Persistencia}: Hash SHA-256 del refresh token se almacena en tabla Sesiones.
  \item \textbf{Respuesta}: Ambos tokens enviados en cookies HttpOnly+Secure+SameSite=Strict.
\end{enumerate}

\subsection{Flujo de Refresh y Rotación de Tokens}

\begin{enumerate}
  \item \textbf{Contexto}: Access token expira, cliente detecta 401 en petición protegida.
  \item \textbf{Petición}: Cliente envía refresh token a \texttt{/api/refresh}.
  \item \textbf{Validación}:
    \begin{itemize}
      \item Servidor hashea el refresh token recibido.
      \item Busca hash en tabla Sesiones.
      \item Si no existe o expiró: 401 Unauthorized, re-login requerido.
    \end{itemize}
  \item \textbf{Rotación} (implementación clave):
    \begin{itemize}
      \item Token válido se \textbf{elimina inmediatamente} de BD (invalidando su uso futuro).
      \item Se genera nuevo access token (15 min).
      \item Se genera nuevo refresh token (7 días).
      \item Hash del nuevo refresh token se almacena en Sesiones.
    \end{itemize}
  \item \textbf{Justificación}: Si el token es comprometido, el usuario legítimo será desautenticado en su próximo refresh (token ya invalidado por atacante). Detecta y contiene brechas.
  \item \textbf{Respuesta}: Nuevos tokens en cookies seguras.
\end{enumerate}

\subsection{Flujo de Logout (Revocación)}

\begin{enumerate}
  \item \textbf{Petición}: Cliente envía petición a \texttt{/api/logout} (con refresh token).
  \item \textbf{Revocación}: Servidor hashea token, busca y \textbf{elimina} registro en Sesiones.
  \item \textbf{Respuesta}: 204 No Content.
  \item \textbf{Limpieza Cliente}: Aplicación borra tokens de su almacenamiento.
\end{enumerate}

Este mecanismo stateful permite revocación permanente e inmediata del lado del servidor, a diferencia de JWTs de acceso (stateless).

\subsection{Flujo de Verificación de Email}

\textbf{Contexto}: Tras registro exitoso, el usuario debe verificar su email antes de poder acceder plenamente a la plataforma. Este flujo previene:
\begin{itemize}
  \item Registro con emails inválidos o pertenecientes a terceros.
  \item Enumeración de usuarios a través del registro.
\end{itemize}

\textbf{Implementación}:

\begin{enumerate}
  \item \textbf{Generación de Token}: Tras registro, servidor genera token de verificación:
    \begin{itemize}
      \item String aleatorio de 32 bytes (cryptographically secure random).
      \item Codificado en base64url para transportabilidad.
      \item Expiración: 24 horas (suficiente para verificación, no abusivo).
    \end{itemize}
  \item \textbf{Almacenamiento}: Token se almacena hasheado en nueva tabla \texttt{EmailTokens}:
    \begin{itemize}
      \item \textbf{hash}: SHA-256 del token (clave única).
      \item \textbf{user\_id}: Referencia al usuario.
      \item \textbf{type}: Identificador del tipo de token (verificación, reset, etc.).
      \item \textbf{expires\_at}: Timestamp de expiración.
      \item \textbf{created\_at}: Timestamp de creación.
    \end{itemize}
  \item \textbf{Transmisión}: Token (sin hashear) se envía por email como enlace: \texttt{https://app.com/verify?token=<token>}.
  \item \textbf{Verificación}:
    \begin{itemize}
      \item Cliente accede enlace con token en querystring.
      \item Servidor hashea token recibido.
      \item Busca hash en tabla EmailTokens.
      \item Si existe, no expiró, y type=``verify'': marca \texttt{email\_verified=TRUE} en tabla Usuarios.
      \item Elimina token de BD (consumo único).
      \item Error genérico 400 si token no válido o expirado (prevenir enumeración).
    \end{itemize}
  \item \textbf{Reintentos}: Endpoint permite reenviar email de verificación (rate limited a 1 por hora) generando nuevo token.
\end{enumerate}

\subsection{Flujo de Recuperación de Contraseña}

\textbf{Contexto}: Usuario que olvidó su contraseña debe poder restablecerla de manera segura. Este flujo es crítico pues representa riesgo elevado si se implementa incorrectamente. Requisitos:
\begin{itemize}
  \item Evitar enumeración de usuarios (no revelar si email existe).
  \item Tokens de reseteo de corta duración (mismo mecanismo de verificación de email).
  \item Prevenir ataques de fuerza bruta sobre el token.
  \item Invalidar token tras uso único.
  \item Revisar si usuario intenta reuso de token comprometido.
\end{itemize}

\textbf{Implementación}:

\begin{enumerate}
  \item \textbf{Petición}: Cliente envía email a \texttt{/api/forgot-password}.
  \item \textbf{Rate Limiting}: Endpoint limitado a 5 solicitudes por IP/hora (prevenir DoS).
  \item \textbf{Búsqueda de Usuario}:
    \begin{itemize}
      \item Servidor busca usuario por email.
      \item \textbf{Respuesta Uniformizada}: Independientemente de si usuario existe, responde:
        \begin{center}
          \texttt{``Si el email existe, recibirá instrucciones de reseteo''}
        \end{center}
      \item \textbf{Justificación}: Previene enumeración de usuarios en el sistema.
    \end{itemize}
  \item \textbf{Generación de Token} (si usuario existe):
    \begin{itemize}
      \item String aleatorio 32 bytes (cryptographically secure).
      \item Expiración: 1 hora (balance entre usabilidad y seguridad).
      \item Hash SHA-256 almacenado en tabla \texttt{EmailTokens} con \texttt{type='password\_reset'}.
      \item Se revoca cualquier token anterior no consumido del mismo tipo para este usuario.
    \end{itemize}
  \item \textbf{Envío Asincrónico}: Token se envía por email (no bloqueante):
    \begin{center}
      \texttt{https://app.com/reset-password?token=<token>}
    \end{center}
  \item \textbf{Verificación del Token}:
    \begin{itemize}
      \item Cliente accede enlace con token.
      \item Servidor hashea token, busca en \texttt{EmailTokens}.
      \item Valida tipo=``password\_reset'' y no expirado.
      \item Si válido: retorna formulario para nueva contraseña (no usuario ni email).
    \end{itemize}
  \item \textbf{Reseteo de Contraseña}:
    \begin{itemize}
      \item Cliente envía token + nueva contraseña a \texttt{/api/reset-password}.
      \item Servidor re-valida token (podría haber expirado).
      \item Valida nueva contraseña (mín. 12 caracteres, complejidad, no reutilización).
      \item Hashea con Argon2id y almacena.
      \item \textbf{Seguridad Adicional}: Revoca todas las sesiones activas del usuario (tabla Sesiones).
        \begin{itemize}
          \item Justificación: Si contraseña fue comprometida, atacante es desconectado.
          \item Usuario legítimo deberá hacer login nuevamente con nueva contraseña.
        \end{itemize}
      \item Elimina token de BD (consumo único).
      \item Envía email de confirmación al usuario notificando reseteo exitoso.
    \end{itemize}
  \item \textbf{Auditoría}: Se registra intento de reseteo (email, timestamp, IP) en logs para detectar patrones sospechosos.
\end{enumerate}

\textbf{Protección contra Ataques}:

\begin{itemize}
  \item \textbf{Token Guessing}: Tokens de 32 bytes = 256 bits de entropía. Espacio de $2^{256}$ combinaciones. Con rate limiting, impracticable.
  \item \textbf{Reuso de Token}: Eliminación inmediata tras consumo previene reuso. Intentos posteriores fallan.
  \item \textbf{Enumeración}: Respuesta uniformizada oculta si usuario existe.
  \item \textbf{Email Interception}: Si correo es interceptado, token expira en 1 hora. TLS y SPF/DKIM mitigan riesgos.
  \item \textbf{Session Hijacking}: Revocación de sesiones previene que atacante mantenga acceso con contraseña antigua.
\end{itemize}

\section{DIAGRAMAS DE SECUENCIA}

Los siguientes diagramas ilustran los flujos críticos del sistema de autenticación.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\textwidth]{1.png}
  \caption{Flujo de Registro: El cliente envía email y contraseña. El servidor valida, hashea la contraseña con Argon2id, y almacena. Se genera token de verificación de email y se envía asincronamente.}
  \label{fig:registro}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\textwidth]{2.png}
  \caption{Flujo de Login: Después de validaciones y rate limiting, se generan access token (JWT, 15 min) y refresh token (opaco, 7 días). Ambos se envían en cookies seguras.}
  \label{fig:login}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\textwidth]{4.png}
  \caption{Flujo de Logout: El servidor revoca el refresh token eliminando su hash de la tabla Sesiones. El acceso token se añade a lista negra. Cliente limpia almacenamiento.}
  \label{fig:logout}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\textwidth]{3.png}
  \caption{Flujo de Refresh: Rotación de tokens - token antiguo se elimina inmediatamente. Si se detecta reuso, se revocan todos los tokens de la familia (indicador de compromiso).}
  \label{fig:refresh}
\end{figure}

\section{DECISIONES CRIPTOGRÁFICAS}

\subsection{Hashing de Contraseñas: Argon2id}

\textbf{Algoritmo}: Argon2id es la recomendación actual de OWASP y ganador de Password Hashing Competition (2015).

\textbf{Ventajas}:
\begin{itemize}
  \item \textbf{Memory-Hard}: Incrementa costo de fuerza bruta tanto en tiempo como en memoria.
  \item \textbf{GPU/ASIC Resistance}: Resistencia superior al hardware especializado vs. bcrypt/PBKDF2.
  \item \textbf{Moderna}: Diseñada considerando tendencias de hardware actual.
\end{itemize}

\textbf{Parámetros OWASP}: memoryCost=19456, timeCost=2, parallelism=1.

\subsection{Firmas de Tokens: RS256 o ES256}

\textbf{Selección}: Algoritmos asimétricos (clave pública/privada) en lugar de HS256.

\textbf{Ventajas}:
\begin{itemize}
  \item Servicio de autenticación firma con clave privada.
  \item Microservicios verifican con clave pública.
  \item Evita compartir secreto simétrico entre servicios.
  \item Escalabilidad y seguridad mejoradas en arquitecturas distribuidas.
\end{itemize}

\subsection{Hashing de Tokens de Verificación y Reseteo}

\textbf{Contexto}: Tokens de email (verificación, reseteo contraseña) son credenciales temporales de alto valor. Si BD se compromete, estos tokens no deben ser reutilizables directamente.

\textbf{Implementación}:
\begin{itemize}
  \item \textbf{Generación}: Token opaco de 32 bytes, codificado base64url.
  \item \textbf{Almacenamiento}: Se calcula SHA-256(token) y se almacena este hash en BD, junto con metadatos (tipo, user\_id, expires\_at).
  \item \textbf{Validación}: Cuando usuario accede enlace, servidor hashea el token recibido y compara con hash almacenado.
  \item \textbf{Defensa}: Incluso si BD es comprometida, atacante solo obtiene hashes unidireccionales. Imposible reconstruir tokens sin inversión SHA-256 (computacionalmente inviable).
\end{itemize}

\section{GESTIÓN DE SESIONES Y ALMACENAMIENTO DE TOKENS}

\subsection{Método: Cookies con Seguridad Reforzada}

Se descarta LocalStorage/SessionStorage por vulnerabilidad inherente a XSS. Los tokens se almacenan en cookies con atributos de seguridad:

\begin{itemize}
  \item \textbf{HttpOnly=True}: Previene acceso desde JavaScript, mitiga XSS.
  \item \textbf{Secure=True}: Solo transmitidas por HTTPS, previene man-in-the-middle.
  \item \textbf{SameSite=Strict}: Restringe envío a peticiones del mismo origen, previene CSRF.
  \item \textbf{Path Específico}: Refresh token con Path=/api/refresh limita scope.
\end{itemize}

\subsection{Inferencia de Estado en Frontend}

Como tokens no son accesibles por JavaScript, el cliente infiere estado de autenticación realizando petición a endpoint protegido (ej. \texttt{/api/me}):
\begin{itemize}
  \item \textbf{200 OK}: Sesión válida, datos del usuario retornados.
  \item \textbf{401 Unauthorized}: Usuario no autenticado.
\end{itemize}

\section{AUTENTICACIÓN MULTIFACTOR (MFA) - DEFENSA EN PROFUNDIDAD}

\textbf{Motivación}: Las contraseñas, incluso hasheadas de forma segura, pueden ser comprometidas por:
\begin{itemize}
  \item Phishing y ingeniería social.
  \item Filtraciones de datos de terceros (reutilización de contraseñas).
  \item Malware local capturando teclas.
  \item Ataques de fuerza bruta exitosos (aunque raros con Argon2id).
\end{itemize}

MFA implementa un segundo factor de autenticación, garantizando que incluso con contraseña comprometida, el atacante no pueda acceder sin el segundo factor.

\subsection{Factores Soportados}

\subsubsection{Factor 1: TOTP (Time-based One-Time Password)}

\textbf{Descripción}: Aplicaciones como Google Authenticator, Authy generan códigos de 6 dígitos cada 30 segundos basados en secreto compartido.

\textbf{Implementación}:
\begin{enumerate}
  \item \textbf{Generación de Secreto}:
    \begin{itemize}
      \item Servidor genera base32-encoded secret de 160 bits (20 bytes).
      \item Se almacena hasheado (SHA-256) en tabla \texttt{MFASecrets}.
      \item Usuario escanea QR (contiene secreto) con app autenticadora.
    \end{itemize}
  \item \textbf{Algoritmo}: RFC 6238 - HMAC-SHA1(secret, tiempo) $\bmod 10^6$.
  \item \textbf{Validación}:
    \begin{itemize}
      \item Usuario ingresa código de 6 dígitos.
      \item Servidor calcula códigos esperados para ventana temporal actual $\pm$ 1 step (30 seg).
      \item Previene sincronización reloj.
      \item Rate limiting: máximo 5 intentos fallidos por intento de login (bloquea 15 min).
    \end{itemize}
  \item \textbf{Recuperación}: Códigos de backup (``recovery codes'') almacenados hasheados:
    \begin{itemize}
      \item 10 códigos alfanuméricos únicos, de un solo uso.
      \item Usuario los guarda en lugar seguro (password manager).
      \item Permite acceso si dispositivo autenticador se pierde.
    \end{itemize}
\end{enumerate}

\textbf{Seguridad}:
\begin{itemize}
  \item \textbf{No requiere conexión}: Funciona offline (a diferencia de SMS/email).
  \item \textbf{Secreto compartido asimétrico}: No se transmite, solo escanea QR.
  \item \textbf{Código corta duración}: Válido solo 60 segundos (ventana $\pm$ 30 seg).
  \item \textbf{Hardware agnostic}: Funciona en cualquier smartphone.
\end{itemize}

\subsubsection{Factor 2: Backup Codes (Códigos de Recuperación)}

\textbf{Propósito}: Acceso de emergencia si autenticador primario se pierde/daña.

\textbf{Generación}: 10 códigos alfanuméricos (12 caracteres) usando cryptographically secure RNG.

\textbf{Almacenamiento}: SHA-256(codigo) almacenado en tabla \texttt{BackupCodes}. Cuando se usan, se marcan como consumidos (usado=TRUE).

\subsection{Flujo de Login con MFA Habilitado}

\begin{enumerate}
  \item \textbf{Paso 1 - Autenticación Primaria}:
    \begin{itemize}
      \item Usuario envía email + contraseña a \texttt{/api/login}.
      \item Servidor verifica credenciales (como en flujo estándar).
      \item Si válidas: no emite tokens aún.
    \end{itemize}
  \item \textbf{Paso 2 - Desafío MFA}:
    \begin{itemize}
      \item Servidor verifica si usuario tiene MFA habilitado (campo \texttt{mfa\_enabled=TRUE}).
      \item Genera \texttt{mfa\_challenge\_id} (UUID temporal con expiración 5 min).
      \item Retorna: \texttt{\{challenge\_id, requires\_mfa: true\}}.
      \item Cliente muestra pantalla para ingreso de código TOTP o backup code.
    \end{itemize}
  \item \textbf{Paso 3 - Validación de MFA}:
    \begin{itemize}
      \item Usuario ingresa código a \texttt{/api/verify-mfa} con \texttt{challenge\_id}.
      \item Servidor valida que \texttt{challenge\_id} existe y no expiró.
      \item Valida código TOTP (con ventana temporal).
      \item Si es backup code: verifica hash, marca consumido.
      \item Rate limiting: 5 intentos fallidos bloquea 15 min.
    \end{itemize}
  \item \textbf{Paso 4 - Emisión de Tokens}:
    \begin{itemize}
      \item MFA validado: genera access + refresh tokens como de costumbre.
      \item Flag \texttt{mfa\_verified=TRUE} en JWT (indica segundo factor verificado).
      \item Elimina \texttt{mfa\_challenge\_id} de BD.
    \end{itemize}
\end{enumerate}

\subsection{Gestión de MFA}

\textbf{Tabla: MFASecrets}

\begin{table}[H]
  \centering
  \small
  \begin{tabular}{|l|l|p{3cm}|}
    \hline
    \textbf{Columna} & \textbf{Tipo} & \textbf{Descripción} \\
    \hline
    id & UUID PK & Identificador \\
    \hline
    user\_id & UUID FK & Usuario propietario \\
    \hline
    secret\_hash & VARCHAR & SHA-256 del secreto TOTP (nunca almacenar en texto plano) \\
    \hline
    mfa\_enabled & BOOLEAN & Flag de habilitación \\
    \hline
    backup\_codes & JSONB & Lista de hashes de códigos de backup \\
    \hline
    created\_at & TIMESTAMP & Fecha de activación \\
    \hline
  \end{tabular}
\end{table}

\textbf{Endpoints}:
\begin{itemize}
  \item \texttt{POST /api/mfa/setup}: Genera QR con secreto. Usuario debe confirmar ingresando código válido antes de habilitar.
  \item \texttt{POST /api/mfa/disable}: Requiere contraseña + código MFA válido. Deshabilita MFA y revoca todas las sesiones (obliga re-login).
  \item \texttt{POST /api/mfa/backup-codes}: Regenera nuevos códigos (invalida anteriores).
\end{itemize}

\subsection{Defensa contra Ataques MFA}

\begin{description}
  \item[Ataque: Time-Synchronization] Si reloj del dispositivo está desfasado. \textbf{Mitigación}: Ventana de $\pm$1 step (30 seg) tolera desviaciones pequeñas.
  \item[Ataque: Fuerza Bruta en TOTP] $10^6$ combinaciones (códigos de 6 dígitos). \textbf{Mitigación}: Rate limiting 5 intentos/15 min; códigos válidos solo 60 seg.
  \item[Ataque: Interceptación de QR] QR con secreto transmitido durante setup. \textbf{Mitigación}: Setup requiere confirmar con código TOTP; si atacante captura QR, debe hacer login para confirmar (no tiene acceso a contraseña).
  \item[Ataque: Phishing de Código TOTP] Usuario engañado ingresa código. \textbf{Mitigación}: Código válido solo 60 seg; contexto de phishing típicamente asincrónico. Implementación futura: risk-based auth detecta anomalías (ubicación, dispositivo).
  \item[Ataque: Pérdida de Dispositivo] Usuario pierde teléfono con autenticador. \textbf{Mitigación}: Backup codes permiten acceso; endpoint \texttt{/api/mfa/disable} requiere contraseña para deshabilitar (acceso a contraseña restablecida vía email de recuperación).
\end{description}

\section{PRIVACIDAD Y MINIMIZACIÓN DE DATOS}

\subsection{Minimización de Datos}

\textbf{Registro}: Solo información estrictamente necesaria para autenticación (email, contraseña).

\textbf{JWT Payload}: Access tokens contienen solo user\_id (UUID) y roles, excluyendo PII. Si endpoint requiere datos del usuario, consulta BD usando user\_id del token.

\subsection{Políticas de Retención}

\begin{itemize}
  \item \textbf{Sesiones}: Cron job purga registros con expires\_at vencido.
  \item \textbf{Logs}: Anonimizados o eliminados tras 90 días de retención.
\end{itemize}

\subsection{Derecho al Olvido}

Sistema provee endpoint de eliminación de cuenta (previa re-autenticación):
\begin{itemize}
  \item Hard delete del registro en tabla Usuarios.
  \item ON DELETE CASCADE elimina en cascada registros en Sesiones.
\end{itemize}

\section{CONCLUSIONES}

El sistema de autenticación diseñado implementa múltiples capas de seguridad:

\begin{enumerate}
  \item \textbf{Primer Factor}: Contraseña hasheada con Argon2id (memory-hard, resistente a GPU).
  \item \textbf{Segundo Factor}: MFA opcional con TOTP + backup codes para defensa contra compromiso de contraseña.
  \item \textbf{Gestión de Sesión}: Tokens JWT de corta duración (15 min) con rotación automática; refresh tokens stateful (7 días) almacenados como hashes para revocación.
  \item \textbf{Verificación de Email}: Tokens únicos de 32 bytes hasheados con SHA-256, consumo único, expiración 24h.
  \item \textbf{Recuperación de Contraseña}: Tokens de reseteo hasheados, expiración 1h, revocación de sesiones tras cambio, respuesta uniformizada para prevenir enumeración.
  \item \textbf{Prevención de Ataques Comunes}: Rate limiting, protección XSS/CSRF (cookies HttpOnly+Secure+SameSite), validaciones de entrada, errores genéricos (no enumeración).
  \item \textbf{Privacidad por Diseño}: Minimización de datos (solo email/contraseña en registro), JWTs sin PII, retención limitada, derecho al olvido.
\end{enumerate}

El sistema cumple con estándares OWASP Top 10, NIST SP 800-63B (nivel 2 con MFA, nivel 3 con recuperación robusto), y reglamentos GDPR. La arquitectura es defensiva en profundidad: compromiso de un factor no garantiza acceso.

Mejoras futuras: WebAuthn (credenciales sin contraseña), análisis de riesgo adaptativo (detección de anomalías geográficas/dispositivo), logging continuo para auditoría, y arquitectura zero trust. La seguridad es un proceso iterativo que requiere revisiones regulares de código, pentesting anual, y actualizaciones de dependencias.

\newpage

\section*{REFERENCIAS}

\begin{enumerate}
  \item OWASP. (2021). OWASP Top Ten 2021. https://owasp.org/Top10/
  \item OWASP. (2023). Authentication Cheat Sheet. https://cheatsheetseries.owasp.org/
  \item NIST. (2020). SP 800-63B: Digital Identity Guidelines - Authentication.
  \item RFC 7519: JSON Web Token (JWT). https://tools.ietf.org/html/rfc7519
  \item RFC 6238: TOTP: Time-Based One-Time Password Algorithm. https://tools.ietf.org/html/rfc6238
  \item Biryukov, A., Dinu, D., \& Khovratovich, D. (2016). Argon2: Memory-hard function for password hashing.
  \item OWASP. Password Storage Cheat Sheet. https://cheatsheetseries.owasp.org/
  \item OWASP. Multi-Factor Authentication Cheat Sheet. https://cheatsheetseries.owasp.org/
  \item Mozilla. Web Security Guidelines. https://infosec.mozilla.org/guidelines/web\_security
  \item EU GDPR (2016/679). Reglamento General de Protección de Datos.
  \item M'Raihi, D., Machani, S., Pei, M., \& Rydell, J. (2011). TOTP: Time-Based One-Time Password Algorithm. RFC 6238.
  \item Wouters, P. (2014). Secure Password Storage and Recovery. White Paper.
\end{enumerate}

\end{document}
